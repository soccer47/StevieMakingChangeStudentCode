Name: Stevie Halprin

| Date   |     Time      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Update |
|:-------|:-------------:|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| Jan 23 | 4:30pm-5:15pm | I spent a long time thinking through the problem set and possible approaches I could take to solve it. I've decided that for my first attempt I'll try to use BFS to get all the possible combinations, and store each combination in a HashMap, using the numbers of each coin as a key and adding a filler boolean as a value. I will use an array of length [# of coins] to represent the number of each coin in a given combination. Using a HashMap will also prevent duplicate entries of the same combination because when you try to add a duplicate entry only the latest entry is kept. |
| Jan 23 | 5:15pm-5:50pm |                                                                                                                                                                                                                                                                                                                                    I wrote out a first draft of the approach I came up with. I spent a lot of time thinking through and then creating the BFS method, and then I filled in the main method accordingly. I just tried running my code, however I got an index out of bounds error. |
| Jan 23 | 5:50pm-6:20pm |                                                  I spent some time debugging and eventually realized that I was initially adding the value of the coin when I should have been adding the index of the coin in the coins array, which was leading to an out of bounds error. After fixing that I went on to fix a few more bugs that popped up. Now when I try to run my code it takes super long for the larger test cases (as in it just keeps going and going and would have probably gone on for many more minutes), and for the smallest test case I am returning one too few possibilities. |
| Jan 23 | 7:30pm-7:50pm |                                                                                                                                                                                                                                                                                                                                            I continued trying to debug my code, but didn't have much success. I made a few edits in an attempt to make my code a bit faster, however I wasn't able to figure out why I'm not returning the right number/undercounting for the smallest test case. |
| Jan 27 |  1pm-1:40pm   |                                                                                                                                                           I brainstormed with Liam and Cody about different possible approaches to the problem set. We tried to come up with ways to avoid repeated paths and also minimize space consumption with our ideas, however by the end of class we hadn't come up with an efficient way to solve the problem set. A lot of our ideas were centered around trying to store the paths in arrays of length # coin or possible hash the values in the path. |
| Jan 31 | 10am-10:40am  |                                                                                                                                                                                                                                                                                                                                                                                                                     I only coded during this time, and finished my first draft of the second attempt. I finished my first draft, however now when I run my code I return -1 for all of the cases. |
| Jan 31 | 4:45pm-5:05pm |                                                                                                                                                                                                                     For some reason I thought I was supposed to return the bottom left most index in the 2D array of # combos, when I should instead just return the output of the call I make to getCombos. After I made this change and a few more edits, my code now passes all of the test cases except for testEfficientLarge, where I return a huge negative int (maybe integer overflow?). |
| Jan 31 | 5:05pm-5:15pm |                                                                                                                                                                                                                                                                                                                                       I got my code to pass all of the test cases by making my getCombos method return a long instead of an int (as well as a few other swaps of ints for longs). I also went through my code and made some final edits to my comments to prepare for submitting. |


To add a new row to the table, click into a cell and then hit shift-enter.